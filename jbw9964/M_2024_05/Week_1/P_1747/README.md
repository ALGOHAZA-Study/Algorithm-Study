
---

## [`1747 번 : 소수&팰린드롬`](https://www.acmicpc.net/problem/1747)

- 알고리즘 분류 : `수학`, `브루트포스`

---

## 🔖 문제 설명

- 어떤 수와 그 순서를 뒤집은 수를 팰린드롬이라 부른다. `N` 보다 크거나 같고, 소수이며 팰린드롬인 수 중에서, 가장 작은 수를 구하여라.

---

## 🛑 문제 제한 조건

- 시간 제한 : $\text{2 s}$
- `N` : $1 \leq \text{N} \leq 1,000,000$

---

## 🍳 스스로 생각한 접근 방식

문제를 생각해보면 결국, 어느 수를 소수인지 판별하고 팰린드롬 수인지 판별하는 문제이다.

그래서 이에 해당하는 메서드를 제작하기로 하였다.

소수판별에 관한 방식은 `에라토스테네스의 체` 방식과 `소수의 정의` 를 이용하기로 하였다.

소수는 결국 `자기 자신보다 작은 소수들로 나누어지지 않는 수` 이므로, `에라토스테네스의 체` 방식으로 `N` 보다 작은 소수를 저장한 후, `N` 보다 큰 수가 소수인지 판별할 때 이용하는 것이다.

팰린드롬 수인지 판별하는 것은 문자열을 이용하면 쉽게 구현할 수 있다.

---


## ❗ 틀린 이유 설명

초기 방식대로 구현하여 코드를 제출하였더니 시간초과가 발생하였다.

그래서 이를 해결하기 위해 여러 방식을 시도하던 중 한가지 사실을 발견하였다.

---

## ✅ 올바른 접근 방식 및 해결 방식

아래의 코드는 초기 코드의 일부이다.

```java
// field
private static List<Integer> primeNumbers = new LinkedList<>();

private static int solve(int N) {
    while (true)    {
        if (isPrime(N) && isPalindrome(N))
        return N;
        N++;
    }
}
```

`N` 이 주어지면 수를 증가시켜 소수이며 팰린드롬인지 확인한다.

아래는 제출하여 $\text{384 ms}$ 가 소요된 코드이다.

```java
// field
private static List<Integer> primeNumbers = new LinkedList<>();

private static int solve(int N) {
    while (true)    {
        if (isPalindrome(N) && isPrime(N))
        return N;
        N++;
    }
}
```

놀랍게도 `isPalindrome` 와 `isPrime` 메서드 호출 순서를 바꿨을 뿐인데 시간초과가 일어나지 않았다.

이는 생각해보면 납득할 만한 이유가 존재한다. 바로 `N` 에 따른 `primeNumbers` 의 크기이다.

초기에 나는 `N` 이 아무리 커도 그보다 작은 소수가 많지 않을 것이라 생각하였다. 하지만 `N` 이 최대일 때 `7.8 만` 개 존재하는 것을 확인하였고, 이 때문에 `isPalindrome` 호출보다 압도적인 비용이 발생하는 것이다.

---

## 🛠 자신의 풀이에서 개선할 부분

이전까지 `소수의 정의` 를 이용한 방식에 이러한 단점이 존재하는 것을 모르고 있었다.

확인해보진 않았지만 `(심지어)` `sqrt` 를 이용해 확인하는 방법이 더 빠를수도 있겠다는 생각이 들었다.

---
