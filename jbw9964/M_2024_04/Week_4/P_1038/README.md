
---

## [`1038 번 : 감소하는 수`](https://www.acmicpc.net/problem/1038)

- 알고리즘 분류 : `브루트포스`

---

## 🔖 문제 설명

- `감소하는 수` 란 어느 정수의 자릿수가 가장 큰 자릿수부터 작은 자릿수까지 감소하는 수를 말한다. `321`, `950` 은 `감소하는 수` 이지만, `322`, `958` 은 아니다.
- `0` 은 `0` 번째 감소하는 수이고, `1` 은 `1` 번째 감소하는 수이다.
- 이 때 `N` 번째 감소하는 수를 출력하라. 존재하지 않으면 `-1` 을 출력한다.

---

## 🛑 문제 제한 조건

- 시간 제한 : $\text{1 s}$
- `N` : $0 \leq \text{N} \leq 1,000,000$

---

## 🍳 스스로 생각한 접근 방식

처음 문제를 마주했을 때, `감소하는 수` 의 개수가 제한되어 있다는 사실을 알아차리지 못했다. `감소하는 수` 중 가장 큰 수는 `9876543210` 이며, 이보다 더 큰 수 중 `감소하는 수` 는 나올 수 없다.

이를 깨닫고 `감소하는 수` 가 어떻게 만들어 질 수 있는지 생각하였다. 그 결과, `마지막 자리수 보다 더 작은 수` 들을 붙이며 생성할 수 있다는 것을 깨달았다.

다음의 수들을 `감소하는 수` 로 알고있다 하자.

|   |   |
|:---:|---|
|감소하는 수|`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`|

이 중 가장 큰 `감소하는 수` 는 `9` 이며, 그 이후의 큰 수는 `10`, `20`, `21` 이다.

여기서 규칙을 찾을 수 있다. `10` 은 `1` 뒤에 `0` 을 붙인 숫자이며, `20`, `21` 는 `2` 뒤에 `0`, `1` 을 붙인 숫자이다.

즉, `이전에 새로 추가된 감소하는 수` 뒤에 `0`, `1`, ... 등을 붙여 새로운 `감소하는 수` 를 만들 수 있다는 것이고, `마지막 자리수` 보다 작은 수들을 붙여 생성한다는 것이다.

이를 깨닫고 다음 방식처럼 만들었다.

```java
private static String[] genArray()  {
    String[] array = new String[1_000_000 + 1];

    for (int i = 0; i <= 9; i++)
    array[i] = String.valueOf(i);

    int indexHead = 0;
    int indexTail = 10;

    while (indexHead < indexTail)   {

        String current = array[indexHead++];
        char lastDigit = current.charAt(current.length() - 1);

        for (char digit = '0'; digit < lastDigit; digit++)
        array[indexTail++] = current + String.valueOf(digit);
    }

    return array;
}
```

`indexHead` 는 `이전에 추가되었던 감소하는 수` 를 지칭하기 위한 `index` 이고, `indexTail` 은 `새롭게 추가되는 감소하는 수` 를 나타내기 위한 `index` 이다.

---

## 🛠 자신의 풀이에서 개선할 부분

초기에는 `Queue` 나 `List` 를 이용하려 하였으나 생각하기 귀찮아서 배열로 풀이하였다.

풀이를 보니 이들을 활용한 풀이가 존재하긴 하나 어느 방식이 더 좋은지는 모르겠다.

다만 위 자료구조를 이용하면 정렬, 탐색 등의 연산이 추가로 필요하다. 반면 나처럼 배열을 이용하면 메모리를 더 많이 사용한다.

어느것이 더 좋은지는 모르겠으나, 이러한 차이점은 분명한 듯 하다.

---

