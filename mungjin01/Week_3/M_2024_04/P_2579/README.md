1칸, 2칸씩 오를 수 있지만 1칸이 연속되어 있으면 안된다는 조건이 걸려있었다.

1칸 연속이 허용되지 않으면 갈 수 있는 방법은

- 1칸 2칸
- 2칸 1칸
- 2칸 2칸

의 순으로 가야 한다.

tip!

항상 bottom 부터 base 값을 할당하여 쌓고, top을 만족하는 하위 조건들을 생각해낸 후 배열을 이용하여 빠르게 연산하자

### Top-Down

1. 큰 문제를 작은 문제로 나눈다.F(n-1), F(n-2)로 나눈다.
2. 작은 문제를 푼다.F(n-1) + F(n-2)

### Bottom-Up

1. 문제를 크기가 작은 문제부터 차례대로 쓴다.
2. 문제의 크기를 조금씩 크게 만들면서 문제를 푼다.
3. 작은 문제를 풀면서 큰 문제의 답을 구한다.

나올 수 있는 경우의 수 2가지

> 내가 지금 밟으려 하는 계단의 숫자가 n이라면, 1) n-2번째 계단을 반드시 밟고, n번째 계단을 밟는 경우 2) n-3번째 계단을 반드시 밟고, n-1번째 계단을 밟고, n번째 계단을 밟는 경우

이렇게 하면 나오는 알고리즘

<aside>
💡 dp[0] = arr[0];

dp[1] = arr[0]+arr[1];

dp[2] = max(arr[0]+arr[2], arr[1]+arr[2]);

3이상부터는 dp[i] = max(dp[i-3]+ arr[i-1]+arr[i], dp[i-2]+arr[i]);

</aside>
